1.배치와 스프링
--

##### 배치 정의
상호작용이나 중단 없이 유한한 양의 데이터를 처리하는 것.   
배치처리가 일단 시작되면, 아무런 개입 없이 어떤 형태로든 완료된다.

##### 배치 처리의 장점
1. 실제 처리가 시작되기 전에 필요한 정보를 미리 수집할 수 있다.  
ex) 월말 거래 내역 조회
2. 자원의 효율적 사용  
    * 일반적인 데이터 모델 처리
        1. 모델의 생성   
        -> 배치 처리로 생성
        2. 생성된 모델을 놓고 새로운 데이터 평가   
        -> 생성된 모델로 실시간 사용

##### 배치 특징
* 사용자의 개입이 없어, 일반 애플리케이션이 가지는 문제가 대체적으로 발생하지 않음
* 사용량 급증과 사용자 중심의 에러 처리 문제는 배치함 처리시 예측이 가능함   
    -> 따라서 확실한 로그와 피드백용 알림을 사용해 신속, 정확하게 에러를 발생시킨다.
    
---

##### 소프트웨어 아키텍처의 공통적인 속성
1. 사용성
2. 유지 보수성
3. 확장성

##### 배치 아키텍처의 속성
1. 사용성(오류 처리 및 유지 보수성과 관련)   
    * 단위테스트가 잘 작성되었는지
    * 왜 실패했는지 알 수 있는지
2. 확장성
    * worker를 여러개 두어 동시 실행?과 같이 큰 규모의 데이터를 다룰 수 있는 것
3. 가용성
    * 필요할 때 배치를 실행할 수 있는지
    * 허용된 시간내에 잡을 수행함으로써 다른 시스템에 영향을 끼치지 않는지
    
###### java를 사용하는 이유
* 유지보수성   
    * 배치 특성상 코드의 수명이 길다.   
    -> 큰 위험 없이 쉽게 수정할 수 있어야한다.   
    * 스프링 프레임워크의 이점을 얻을 수 있다.
* 유연성
    * 배포를 위한 JVM의 유연성(OS)
* 개발 리소스
* 확장성
* 비용

---
##### 스프링 배치 일반적인 사용
1. ETL(추출-Extract, 변환-Transform, 적재-Load)
2. 데이터 마이그레이션
    * 테스트가 가능하다.
    * 커밋 횟수 측정, 롤백과 같은 기능 제공
3. 병렬 처리
    * 단일 작업을 빨리하는 것보다, 많은 작업을 병렬로 처리하는 것이 성능의 향상의 지름길이다.
    
---
##### 스프링 배치 프레임워크
레이어 구조(3 tier)
* 애플리케이션 레이어   
    -> 배치 처리 구축의 코드 및 구성   
    (코어와 인프라스트럭쳐를 감싸고 있음)
* 코어   
    * 잡 - 중단이나 상호작용 없이 처음부터 끝까지 실행되는 처리
    * 스텝 - 잡과 관련된 입력과 출력이 있을 수 있음   
    +) 잡(1) : 스텝(1..N)
* 인프라스트럭처   
    -> 데이터를 읽고 씀   
    -> 잡 수행 실패 후 재시도시 어떤일을 수행할지 선택

스프링 기반으로 구축   
-> 의존성 주입, AOP, 트랜잭션 관리등의 필요한 기능을 사용 가능 


2.스프링 배치
--

##### 잡과 스텝
잡 - (스텝1 -> 스텝2 -> 스텝3)
* 스텝 : 잡을 구성하는 독립된 작업 단위
    * tasklet 기반   
    -> 스텝이 중지될 때까지 execute 메서드가 반복적 수행   
    (execute마다 독립된 트랜잭션을 가짐)
    * chunk 기반   
    -> 아이템 기반 처리에 사용   
        * ItemReader
        * ItemProcessor (필수 아님)
        * ItemWriter   

스텝을 분리함으로써 얻는 이점
* 유연성
* 유지 보수성   
-> 각 스텝의 코드는 독립적이므로 다른 스텝에 영향을 끼치지 않음
* 확장성   
-> 각 스텝을 병렬로 실행 가능
* 신뢰성   
-> 스텝의 여러 단계에 적용할 수 있는 강력한 오류 처리 방법 제공   
(재시도, 스킵)


##### 잡 실행

* JobRepository   
-> 다양한 배치 수행과 관련된 수치 데이터와 잡의 상태를 유지 관리한다.   
(주로 RDB를 사용하여 관련 정보(배치의 시작&종료 시간, 상태, 읽기&쓰기 횟수)를 공유한다.)
![image](https://godekdls.github.io/images/springbatch/batch-stereotypes.png)

* JobLauncher   
-> 잡을 실행하는 역할을 담당   
-> Job.execute를 호출, 재실행가능 여부, 잡의 실행 방법, 유효성 검증 등을 수행   
* JobInstance   
-> 잡의 이름과 잡의 논리적 실행을 위헤 제공되는 고유한 파라미터 식별 모음   
(잡이 다른 파라미터로 실행될 때마다 새로운 JobInstance 생성)
* JobExecution   
-> 스프링 배치잡의 실제 실행을 의미   
-> 잡을 구동할 때마다 매번 새로운 JobExecution을 얻게됨
-> 실패한 잡을 재실행시 새로운 JobInstance를 얻지 못하고 새로운 JobExecution이 생성됨
* StepExecution스텝   
-> 실제 실행을 의미함   
-> 일반적으로 JobExecution은 여러 개의 StepExecution과 관계가 있음

##### 병렬화
1. 다중 스레드 스텝을 통한 작업분할   
-> 청크라는 블록단위로 처리되도록 구성(각각 독립적인 트랜잭션)  
-> 전체 레코드가 1,000개이고, 커밋단위를 100개로 설정했다면 2개의 스레드로 처리할 경우 이론상 2배의 처리량을 갖는다.
2. 전체 스텝의 병렬 실행   
-> 각 스텝이 영향을 끼치지 않는다면, 기다릴 필요 없이 병렬로 스텝을 처리할 수 있다.
3. 비동기 ItemProcessor, ItemWriter 구성   
-> 스텝 내의 ItemProcessor가 병목현상을 일으킬 수 있다. 현재 청크 내에서 Future를 반환하며 비동기 처리를 할 수 있다.
4. 원격 청킹   
-> 메시지 브로커(Rabbit MQ, Active MQ)를 통해 원격 청킹이 가능하다.   
(마스터에서 데이터를 읽고 원격 워커에 처리 후 다시 마스터로 전송하므로 네트워크 사용량이 많아질 수 있음) 
5. 파티셔닝   
-> 마스터는 워커의 스텝 수집을 위한 컨트롤러 역할만 함   
-> 모든 워커의 스텝은 독립적으로 동작

##### annotation
* EnableBatchProcessing   
    -> 배치 인프라스트럭처를 위한 대부분의 스프링 빈 정의를 제공
    * JobRepository
    * JobLauncher
    * JobExplorer
    * PlatformTransactionManager
    * JobBuilderFactory
    * StepBuilderFactory